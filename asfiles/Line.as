/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS' OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package asfiles {		import flash.display.Sprite;	import flash.events.MouseEvent;		public class Line extends GraphShape {		private var wdth:Number,hght:Number,soffset:Number;		private var cells:Array=new Array();		private var lg:LineGraph;			public function Line(screen:Sprite,lg:LineGraph) {			super(screen);this.lg=lg;		}						public function interpolate(xx:Number):String {			var p:int=Math.floor(xx/wdth);			var r:Number=(xx-p*wdth)/wdth;			if (r<0.05) return '* '+lg.formatit(cellvalue(cells[p]));			else if (r>0.95) return '* '+lg.formatit(cellvalue(cells[p+1]));			return lg.formatit(Math.round(((1-r)*cellvalue(cells[p])+r*cellvalue(cells[p+1]))*100)/100);		}						private function cellvalue(cell:Cell):Number {			return (cell!=null && cell.isvalue) ? cell.value : 0;		}						private function ycoord(cell:Cell):int {			return soffset-hght*cellvalue(cell);		}						public function moveto(c:uint,soffset:Number,wdth:Number,hght:Number,cell:Cell):void {			this.wdth=wdth;this.soffset=soffset;this.hght=hght;			graphics.clear();			graphics.lineStyle(2,colour=c);			graphics.moveTo(0,ycoord(cells[0]=cell));		}		public function lineto(i:int,cell:Cell):void {			graphics.lineTo(i*wdth,ycoord(cells[i]=cell));		}						override public function mouseover(ev:MouseEvent):void {			Cursor.changecursor(stage,altcursor);			Cursor.cursorhint(stage,interpolate(mouseX));			addEventListener(MouseEvent.MOUSE_MOVE,mousemove);			for (var i:int=0;i<cells.length;i++) if (cells[i]!=null) {cells[i].backgroundColor=colour;cells[i].background=true;}		}						override public function mouseout(ev:MouseEvent):void {			removeEventListener(MouseEvent.MOUSE_MOVE,mousemove);			Cursor.changecursor(stage);			Cursor.cursorhint(stage);			for (var i:int=0;i<cells.length;i++) if (cells[i]!=null) {cells[i].backgroundColor=0xffffff;cells[i].background=false;}		}						private function mousemove(ev:MouseEvent):void {			Cursor.cursorhint(stage,interpolate(mouseX));		}	}}