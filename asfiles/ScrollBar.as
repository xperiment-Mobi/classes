/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS' OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package asfiles {		import flash.display.GradientType;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.utils.Timer;	public class ScrollBar extends ScrollBarSkins {		public static const RESIZE:String='scrollbar.resize';		public static const STARTDRAG:String='scrollbar.startdrag';		public static const STOPDRAG:String='scrollbar.stopdrag';		public static const FOCUS:String='scrollbar.focus';		public const scrollmargin:int=20;		//32;		public const fac:Number=1.5;		public const lim:int=20;		public const step:int=8;		public const limx:int=256;		public const limy:int=128;				private const focusmarginx:int=20;		//80;		private const focusmarginy:int=32;		//64;				private var lastdx:int=0;		private var posn:int;		private var mouseisdown:Boolean=false;		private var offset:int;		private var mystep:int;				private var timer:Timer = new Timer(50, 0);		private var timer0:Timer = new Timer(50, 0);		private var timer1:Timer = new Timer(50, 0);		private var delay:Timer = new Timer(400, 1);				private var target:int;		private var screenobj:*;		private var horizontal:Boolean;				private var grefresh:Function=null;				protected var _inactiveInvisible:Boolean;			public function ScrollBar(screen:Sprite,xx:int,yy:int,heigt:int,screenobj:*=null,horiz:Boolean=false,inactiveInvisible:Boolean=false,buttons:Boolean=true) {		this.screenobj=screenobj;horizontal=horiz;		_inactiveInvisible=inactiveInvisible;		super(screen,xx,yy,heigt,buttons);		if (!horiz) stage.addEventListener(MouseEvent.MOUSE_WHEEL,mousewheel);		sb_slider.addEventListener(MouseEvent.MOUSE_DOWN,startslide);		sb_track.addEventListener(MouseEvent.MOUSE_DOWN,startslide);		sb_upbtn.addEventListener(MouseEvent.MOUSE_DOWN,moveit);		sb_downbtn.addEventListener(MouseEvent.MOUSE_DOWN,moveit);		sb_upbtn.addEventListener(MouseEvent.MOUSE_OVER,moveit1);		sb_downbtn.addEventListener(MouseEvent.MOUSE_OVER,moveit1);		if (horiz) {x=x+heigt;y-y-wdth;rotation=90;}		screenobj.addEventListener(RESIZE,reset);		screenobj.addEventListener(STARTDRAG,startdrag);		screenobj.addEventListener(STOPDRAG,stopdrag);		screenobj.addEventListener(FOCUS,focus);		timer.addEventListener(TimerEvent.TIMER,tick);	//	reset();	//	tick();//		reset();		if (horiz && !buttons) sb_posn=range;		sb_upbtn.visible = sb_downbtn.visible = buttons;	}			private function activate(st:Boolean):void {		sb_slider.visible=st;		sb_track.visible=st;		sb_upbtn.visible=st;		sb_downbtn.visible=st;	}			private function drawinactive(style:Array):void {		var matr:Matrix=new Matrix();		matr.createGradientBox(wdth, sb_slider.height+2*wdth, 0, 0, 0);		graphics.clear();		graphics.beginGradientFill(GradientType.LINEAR,style,[1,1,1],[0x00,0x66,0xff],matr);		graphics.lineStyle(1,0xdddddd);	//	graphics.lineGradientStyle(GradientType.RADIAL,lindgr,[1,1],[0x00,0xff],matr);		graphics.drawRect(0,1,wdth,sb_track.height+(_buttons ? 2*wdth : 0)-2);		if (_inactiveInvisible) visible=sb_slider.visible;	}	public function reset(...ev):void {//trace('ScrollBar.reset');		var rect:Rectangle=screenobj.scrollRect;		if (!rect) {sb_upbtn.arrow.visible=sb_downbtn.arrow.visible=sb_slider.visible=false;activate(false);drawinactive(inacti);return;}		else if (horizontal) {			if (rect.width>=screenobj.totalwidth) {sb_upbtn.arrow.visible=sb_downbtn.arrow.visible=sb_slider.visible=false;activate(false);sb_posn=0;}			else {				sb_upbtn.arrow.visible=sb_downbtn.arrow.visible=sb_slider.visible=true;activate(true);				sb_slider.height=Math.max(rect.width/screenobj.totalwidth*sb_track.height,14);			//	sb_slider.y					sb_posn=sb_track.y+(sb_track.height-sb_slider.height)*(1-rect.x/(screenobj.totalwidth-rect.width));			}		} else {			if (rect.height>=screenobj.totalheight) {				sb_upbtn.arrow.visible=sb_downbtn.arrow.visible=sb_slider.visible=false;				activate(false);			//	sb_slider.y=0					sb_posn=0;			} else {				sb_upbtn.arrow.visible=sb_downbtn.arrow.visible=sb_slider.visible=true;activate(true);				sb_slider.height=Math.max(rect.height/screenobj.totalheight*sb_track.height,14);			//	sb_slider.y					sb_posn=sb_track.y+(sb_track.height-sb_slider.height)*rect.y/(screenobj.totalheight-rect.height);			}		}		drawinactive(inacti);		sb_posn=sb_posn;	}	private function startdrag(ev:*):void {		timer.start();if (ev.parameters.length>0) grefresh=ev.parameters[0]; else grefresh=null;	}			private function focus(ev:Object):void {		var thing:Object=ev.parameters[0];		var objrect:Rectangle=thing.getBounds(screenobj.parent);		var scnrect:Rectangle=screenobj.scrollRect;		if (!scnrect) return;		var starthere:int=screenobj.hasOwnProperty("starthere") ? screenobj.starthere : 0;		var xx:Number=objrect.x-screenobj.x;		var yy:Number=objrect.y-screenobj.y+starthere;		if (ev.parameters[1]!=undefined) {xx+=ev.parameters[1];objrect.width=0;}		if (ev.parameters[2]!=undefined) {yy+=ev.parameters[2];objrect.height=0;}		if (horizontal) {			if (xx<focusmarginx)			{				scnrect.y+=starthere;				scnrect.x-=focusmarginx-xx;				bugfix(scnrect);				screenobj.scrollRect=scnrect;				reset();			}			else if (xx+objrect.width>screenobj.width-focusmarginx) {scnrect.x+=(xx+objrect.width)-(screenobj.width-focusmarginx);screenobj.scrollRect=scnrect;reset();}		} else {			if (yy-starthere<focusmarginy)			{				scnrect.y-=focusmarginy-yy+starthere;				bugfix(scnrect);				screenobj.scrollRect=scnrect;				reset();			}			else if (yy+objrect.height-starthere>screenobj.height-focusmarginy)			{				scnrect.y+=(yy+objrect.height)-(screenobj.height-focusmarginy)-starthere;				bugfix(scnrect);				screenobj.scrollRect=scnrect;				reset();			}		}	}			private function tick(ev:TimerEvent = null):void {		var scnrect:Rectangle=screenobj.scrollRect;		var starthere:int=screenobj.hasOwnProperty("starthere") ? screenobj.starthere : 0;		var xx:int=stage.mouseX-screenobj.x;		var yy:int=stage.mouseY-screenobj.y;				var dlta:Number;		if (scnrect)		{			if (horizontal) {				if (xx<scrollmargin) {scnrect.x-=limx/8+Math.min(limx,scrollmargin-xx);bugfix(scnrect);screenobj.scrollRect=scnrect;reset();}				else if (xx>screenobj.width-scrollmargin) {scnrect.x+=limx/8+Math.min(limx,xx-(screenobj.width-scrollmargin));bugfix(scnrect);screenobj.scrollRect=scnrect;reset();}			} else {				if (yy<scrollmargin) {scnrect.y-=limy/8+Math.min(limy,scrollmargin-yy);bugfix(scnrect);screenobj.scrollRect=scnrect;reset();}				else if (yy>screenobj.height-scrollmargin) {					dlta=limy/8+Math.min(limy,yy-(screenobj.height-scrollmargin));					scnrect.y=scnrect.y+dlta;					bugfix(scnrect);					screenobj.scrollRect=scnrect;					reset();					}			}		}		if (grefresh!=null)			grefresh();	}			protected function bugfix(scnrect:Rectangle):void	{		if (isNaN(scnrect.x)) {scnrect.x=0;trace('*caught and corrected ScrollBar bug on x');}		if (isNaN(scnrect.y)) {scnrect.y=0;trace('*caught and corrected ScrollBar bug on y');}	}	private function stopdrag(ev:*):void {		timer.stop();	}	override public function set sb_posn(v:int):void {		var rect:Rectangle = screenobj.scrollRect;		if (!rect) return;		super.sb_posn=v;		posn=sb_posn;		if (horizontal) rect.x=(!sb_slider.visible) ? 0 : (screenobj.totalwidth-rect.width)*(1-position);		else rect.y=(!sb_slider.visible) ? 0 : (screenobj.totalheight-rect.height)*position;		bugfix(rect);		screenobj.scrollRect=rect;	}	private function mousewheel(ev:MouseEvent):void {		sb_posn-=ev.delta;	}	private function moveit(ev:MouseEvent):void {		stage.addEventListener(MouseEvent.MOUSE_UP,stopmoving);		sb_upbtn.addEventListener(MouseEvent.MOUSE_OUT,stopmoving);		sb_downbtn.addEventListener(MouseEvent.MOUSE_OUT,stopmoving);		if (ev.target==sb_upbtn) sb_posn=sb_posn+(mystep=-step); else sb_posn=sb_posn+(mystep=step);		delay.addEventListener(TimerEvent.TIMER, moveit2);		delay.start();	}		private function moveit1(ev:MouseEvent):void {		if (ev.buttonDown) moveit(ev);	}		private function moveit2(ev:TimerEvent):void {		delay.removeEventListener(TimerEvent.TIMER, moveit2);		timer1.addEventListener(TimerEvent.TIMER, moveit3);		timer1.start();			}		private function moveit3(ev:TimerEvent):void {		sb_posn=sb_posn+mystep;	}		private function stopmoving(ev:MouseEvent):void {		sb_upbtn.removeEventListener(MouseEvent.MOUSE_OUT,stopmoving);		sb_downbtn.removeEventListener(MouseEvent.MOUSE_OUT,stopmoving);		if (stage) stage.removeEventListener(MouseEvent.MOUSE_UP,stopmoving);		delay.removeEventListener(TimerEvent.TIMER, moveit2);		timer1.removeEventListener(TimerEvent.TIMER, moveit3);	}	private function startslide(ev:MouseEvent):void {		stage.addEventListener(MouseEvent.MOUSE_UP,stopslide);		if (ev.target==sb_slider) offset=mouseY-sb_posn-wdth;		else if (mouseY<sb_posn+wdth) offset=0; else offset=sb_slider.height;		mouseisdown=true;		timer0.addEventListener(TimerEvent.TIMER, adjust);		timer0.start();	}		private function stopslide(ev:MouseEvent):void {		if (stage) stage.removeEventListener(MouseEvent.MOUSE_UP,stopslide);		mouseisdown=false;	}	private function limit(num:Number,lim:Number):Number {		if (num>lim) return lim; else if (num<-lim) return -lim; else return num;	}	private function adjust(ev:TimerEvent):void {	var distance:Number;	if (mouseisdown) target=mouseY-wdth-offset;	if (target<0) target=0;else if (target>range) target=range;	distance=(target-posn)/fac;	if (Math.abs(lastdx)<1) if (distance>0) lastdx=1; else this.lastdx=-1;	this.limit(distance,Math.abs(lastdx*fac));	this.limit(distance,lim);	if (Math.abs(distance)<1) {		if (!mouseisdown) timer0.removeEventListener(TimerEvent.TIMER, adjust);		posn=target;distance=0;		} else posn+=(lastdx=distance);	sb_posn=posn;	}			public function destructor():void {		stage.removeEventListener(MouseEvent.MOUSE_WHEEL,mousewheel);		sb_upbtn.removeEventListener(MouseEvent.MOUSE_DOWN,moveit);		sb_downbtn.removeEventListener(MouseEvent.MOUSE_DOWN,moveit);		sb_upbtn.removeEventListener(MouseEvent.MOUSE_OVER,moveit1);		sb_downbtn.removeEventListener(MouseEvent.MOUSE_OVER,moveit1);		sb_upbtn.removeEventListener(MouseEvent.MOUSE_DOWN,sb_upbtn.mdown);		sb_upbtn.removeEventListener(MouseEvent.MOUSE_OVER,sb_upbtn.mover);		sb_downbtn.removeEventListener(MouseEvent.MOUSE_DOWN,sb_downbtn.mdown);		sb_downbtn.removeEventListener(MouseEvent.MOUSE_OVER,sb_downbtn.mover);		screenobj.removeEventListener(RESIZE,reset);		screenobj.removeEventListener(STARTDRAG,startdrag);		screenobj.removeEventListener(STOPDRAG,stopdrag);		screenobj.removeEventListener(FOCUS,focus);		timer.removeEventListener(TimerEvent.TIMER,tick);	}								  	}}