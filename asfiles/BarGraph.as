/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS' OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package asfiles {		import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.utils.ByteArray;	import flash.text.TextFormat;	import flash.text.TextFieldAutoSize;	public class BarGraph extends GraphPalette {				private const msgformat:TextFormat=new TextFormat('Arial',14,0x333399);		private var index:Array = new Array();		public var bars:Array=new Array();		private var bw:Number;		private var errmsg:PrintAt;		public function BarGraph(screen:Sprite,xx:int,yy:int,select:Packet,ss:*=null,freq:Boolean=false) {		errmsg=new PrintAt(this,wdth/2,hght/2,'invalid data',TextFieldAutoSize.CENTER,msgformat);		iam=0;super(screen,xx,yy,select,ss,freq);		resize(wdth,hght);		}						private function setsizes(wdth:Number):void {			bw=0.7;if (threed && !stack) bw=0.6;			else if (stack && !threed) bw=bw+0.05;			if (threed) thick=bw*wdth/3; else thick=0;			if (thick>8) thick = 8;		}					//	private function controlsclick(ev:MouseEvent):void {		//	if (ev.target==controls.threedbtn) threed=!threed;		//	else if (ev.target==controls.stackbtn) stack=!stack;		//	else if (ev.target==controls.swapbtn) swap=!swap;		//	else		//	if (ev.target==controls.legendbtn) {		//		legend.visible=!legend.visible;		//		extra=legend.visible ? legend.width : 0;		//		redraw(lcolour);		//		}		//	drawaxis();		//	bgredraw();		//	gridbehind();	//	}		private function cellvalue(i:int,j:int):Number {			if (freq) if (frequencybin==null || frequencybin.length==0) return 0; else return frequencybin[i][j];			else {				var cell:Cell=readcell(i,j);				if (cell==null) return 0;				else if (!cell.isvalue || isNaN(cell.value)) return 0;				else return cell.value;				}		}						private function errmessage(st:Boolean):void {			errmsg.visible=st;			errmsg.x=(wdth-errmsg.width)/2;			errmsg.y=(hght-errmsg.height)/2;			drawax.visible=grph.visible=gridbe.visible=!st;			scale.visible=st ? false : wdth>scalewidth;					}				override public function bgredraw():void {			var bar:Sprite;			var wdth:Number;			var t:Number;			var neg:Array=new Array();			var x0:Number;			var i:int,j:int;			var maxv:Number;			drawax.graphics.clear();			if (freq && !frequencymode && !enumerationmode) errmessage(true);			else if (!freq && no<1) {if (freq) errmessage(true);}			else {				errmessage(false);				if (freq) clear();				wdth=mywidth/no;				setsizes(wdth);			//	hght = myheight/srange;				if ((datai>1) && stack && threed) {					if (swap) {						wdth = mywidth/dataj;setsizes(wdth);						for (j=0;j<dataj-1;j++) {							neg[j]=true;							for (i=0;i<datai;i++) if (cellvalue(i,j+1)>0) neg[j]=false;							}						neg[dataj-1]=true;						for (j=0;j<dataj;j++) dddaxis((j+bw)*wdth,(j+1)*wdth,neg[j]);					} else {						wdth = mywidth/datai;setsizes(wdth);						for (i=0;i<datai-1;i++) {							neg[i]=true;							for (j=0;j<dataj;j++) if (cellvalue(i+1,j)>0) neg[i]=false;							}						neg[datai-1]=true;						for (i=0;i<datai;i++) dddaxis((i+bw)*wdth,(i+1)*wdth,neg[i]);					}				}				if (datai == 1) {					for (i = 0; i<dataj; i++) {						plotbar(grph,wdth, shght, soffset, readcell(0,i), i, i, colour(0,i), true,freq ? cellvalue(0,i) : -1,frequencylabel(i));						if (threed) dddaxis((i+bw)*wdth,(i+1)*wdth,cellvalue(0,i+1)<=0);					}			//	legend.redraw(hght,dataj);				} else {					if (!stack && dataj>1)						if (swap) wdth = mywidth/(dataj*(datai+1)-1);						else wdth = mywidth/(datai*(dataj+1)-1);					else if (swap) wdth = mywidth/dataj;						else wdth = mywidth/datai;						setsizes(wdth);								//sort.						if (stack) {							if (swap) {							for (j = 0; j<dataj; j++) {								for (i = 0; i<datai; i++) index[i] = i;																for (i = 1; i<datai; i++)									while (Math.abs(cellvalue(index[i-1],j))<Math.abs(cellvalue(index[i],j))) {										t = index[i-1];										index[i-1] = index[i];										index[i] = t;										if (i>1) i--;									}																	maxv = Number.NEGATIVE_INFINITY;								for (i = 0; i<datai; i++) if ((t=cellvalue(i,j))>maxv) maxv = t;								for (i = 0; i<datai; i++) plotbar(grph, wdth, shght, soffset, readcell(index[i],j), i*dataj+j, j, colour(index[i],j), cellvalue(index[i],j) == maxv,freq ? cellvalue(index[i],j) : -1,frequencylabel(j));								for (i = 0; i<datai; i++) if ((bar=bars[j*datai+i])!=null) grph.setChildIndex(bar,j*datai+i);								}							} else {							for (i = 0; i<datai; i++) {								for (j = 0; j<dataj; j++) index[j] = j;																for (j = 1; j<dataj; j++)									while (Math.abs(cellvalue(i,index[j-1]))<Math.abs(cellvalue(i,index[j]))) {										t=index[j-1];										index[j-1] = index[j];										index[j] = t;										if (j>1) j--;									}																	maxv = Number.NEGATIVE_INFINITY;								for (j = 0; j<dataj; j++) if ((t=cellvalue(i,j))>maxv) maxv = t;								for (j = 0; j<dataj; j++) plotbar(grph, wdth, shght, soffset, readcell(i,index[j]), i*dataj+j, i, (dataj == 1) ? colour(i) : colour(i,index[j]), cellvalue(i,index[j]) == maxv,freq ? cellvalue(i,index[j]) : -1,frequencylabel(i));								for (j = 0; j<dataj; j++) if ((bar=bars[i*dataj+j])!=null) grph.setChildIndex(bar,i*dataj+j);								}							}						} else {							for (i = 0; i<datai; i++)								for (j = 0; j<dataj; j++) {									if (swap) x0=(datai>1) ? i+(datai+1)*j : j; else x0=(dataj>1) ? j+(dataj+1)*i : i;									plotbar(grph, wdth, shght, soffset, readcell(i,j), (dataj==1) ? i : i*dataj+j, x0, colour(i,j), true,freq ? cellvalue(i,j) : -1,frequencylabel((dataj==1) ? i : j));									if (threed) if (swap) dddaxis((((datai==1) ? j : i+(datai+1)*j)+bw)*wdth,((datai>1 && i==datai-1 && j<dataj-1) ? wdth : 0)+((datai==1) ? (j+1) : (i+1)+(datai+1)*j)*wdth,((i==datai-1) ? cellvalue(0,j+1) : cellvalue(i+1,j))<=0);											else dddaxis((((dataj==1) ? i : j+(dataj+1)*i)+bw)*wdth,((dataj>1 && j==dataj-1 && i<datai-1) ? wdth : 0)+((dataj==1) ? (i+1) : (j+1)+(dataj+1)*i)*wdth,((j==dataj-1) ? cellvalue(i+1,0) : cellvalue(i,j+1))<=0);								}						}				}			}	}			private function clear():void {		for (var i:int=0;i<bars.length;i++) if (bars[i]!=null) bars[i].destructor();		bars=new Array();	}			public function plotbar(screen:Sprite,wdth:Number, hght:Number, soffset:Number, cell:Cell, i:int, xx:int, c:uint, top:Boolean,fval:int,flabel:String):void {		if (bars[i]==null) bars[i]=new Bar(screen);		bars[i].drawbar(wdth,hght,freq ? null : cell,soffset,xx,c,threed,stack,top,fval,flabel);		}	public function dddaxis(x0:Number,x1:Number,neg:Boolean):void {		drawax.graphics.beginFill(0xccccff,0.5);		drawax.graphics.lineStyle(0,0,0);		drawax.graphics.moveTo(x0,soffset);		drawax.graphics.lineTo(x0+thick,soffset-thick);		drawax.graphics.lineTo(x1+(neg ? thick : 0)-1,soffset-thick);		drawax.graphics.lineTo(x1-1,soffset);		drawax.graphics.lineTo(x0,soffset);		drawax.graphics.endFill();				}	}}