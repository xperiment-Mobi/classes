/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS' OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package asfiles {			import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.display.Graphics;	import flash.display.GradientType;	import flash.geom.Matrix;	import flash.filters.DropShadowFilter;	public class ScrollBarSlider extends ScrollBarStyle {				private var horizontal:Boolean;		private var slht:int;					public function ScrollBarSlider(screen:Sprite,xx:int,yy:int,horiz:Boolean=false) {			x=xx;y=yy;horizontal=horiz;			height=100;			screen.addChild(this);			addEventListener(MouseEvent.MOUSE_OVER,mover);			addEventListener(MouseEvent.MOUSE_OUT,mout);			addEventListener(MouseEvent.MOUSE_DOWN,mdown);		}				public function mover(ev:MouseEvent):void {			redraw(rollov,linacr,oncolour);		}				public function mout(ev:MouseEvent):void {			redraw(normal,linegr,midcolour);		}				public function mdown(ev:MouseEvent):void {			stage.addEventListener(MouseEvent.MOUSE_UP,mup);			removeEventListener(MouseEvent.MOUSE_OVER,mover);			removeEventListener(MouseEvent.MOUSE_OUT,mout);			redraw(active,lindgr,midcolour);		}		public function mup(ev:MouseEvent):void {			addEventListener(MouseEvent.MOUSE_OVER,mover);			addEventListener(MouseEvent.MOUSE_OUT,mout);			if (stage) stage.removeEventListener(MouseEvent.MOUSE_UP,mup);			redraw(normal,linegr,midcolour);		}						override public function set height(value:Number):void {			slht=Math.round(value);			redraw(normal,linegr,midcolour);		}		public function redraw(fillstyle:Array,linestyle:Array,mcolour:uint):void {			var matr:Matrix=new Matrix();			var myfilters:Array=new Array();			graphics.clear();			matr.createGradientBox(wdth, slht, Math.PI/2, 0, 0);			graphics.beginGradientFill(GradientType.LINEAR,fillstyle,[100,100],[0x00,0xff],matr);			graphics.lineStyle(1,linestyle[0]);			graphics.lineGradientStyle(GradientType.RADIAL,linestyle,[100,100],[0x00,0xff],matr);			graphics.moveTo(1,0);			graphics.lineTo(wdth-crnr-2,0);			graphics.curveTo(wdth-1,0,wdth-1,crnr);			graphics.lineTo(wdth-1,slht-crnr);			graphics.curveTo(wdth-1,slht,wdth-crnr-1,slht);			graphics.lineTo(1,slht);			graphics.lineTo(1,0);			graphics.endFill();						myfilters.push(new DropShadowFilter(3.0,horizontal ? 150 : 60,0x999999));            filters=myfilters;			middle(mcolour);		}				private function middle(colour:uint):void {			graphics.lineStyle(0,0,0);			graphics.beginFill(colour);			graphics.drawRect(wdth/2-arsz,Math.floor(slht/2-4),arsz*2,1);			graphics.drawRect(wdth/2-arsz,Math.floor(slht/2-2),arsz*2,1);			graphics.drawRect(wdth/2-arsz,Math.floor(slht/2-0),arsz*2,1);			graphics.drawRect(wdth/2-arsz,Math.floor(slht/2+2),arsz*2,1);				graphics.drawRect(wdth/2-arsz,Math.floor(slht/2+4),arsz*2,1);				}			}}