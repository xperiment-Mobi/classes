/** * <p>Original Author: Daniel Freeman</p> * * <p>Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions:</p> * * <p>The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software.</p> * * <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE.</p> * * <p>Licensed under The MIT License</p> * <p>Redistributions of files must retain the above copyright notice.</p> */package com.danielfreeman.extendedMadness {	import com.danielfreeman.madcomponents.*;		import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.InteractiveObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.MouseEvent;	import flash.events.TextEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.text.TextFormat;/** * A list row was clicked.  This is a bubbling event. */	[Event( name="clicked", type="flash.events.Event" )]/** * A list row was long-clicked. */	[Event( name="longClick", type="flash.events.Event" )]	/** *  MadComponents List * <pre> * &lt;listHorizontal *    id = "IDENTIFIER" *    colour = "#rrggbb" *    background = "#rrggbb, #rrggbb, ..." *    visible = "true|false" *    gapV = "NUMBER" *    gapH = "NUMBER" *    border = "true|false" *    autoLayout = "true|false" *    lines = "i,j,k..." *    pullDownRefresh = "true|false" *    pullDownColour = "#rrggbb" *    sortBy = "IDENTIFIER" *    sortMode = "MODE" *    index = "INTEGER" *    showPressed = "true|false" *    highlightPressed = "true|false" *    mask = "true|false" *    alignV = "scroll|no scroll" *    width = "NUMBER" *    height = "NUMBER" *    rowWidth = "NUMBER" * /&gt; * </pre> */	public class UIListHorizontal extends UIList {				protected static const MINIMUM_BAR_WIDTH:Number = 16.0;		protected var _rowWidth:int = -1;		public function UIListHorizontal(screen:Sprite, xml:XML, attributes:Attributes) {			if (xml.@rowWidth.length()>0)				_rowWidth = parseInt(xml.@rowWidth);			_attributes = attributes;			initialiseRenderAttributes(xml, attributes);			super(screen, xml, attributes);			_top = _search ? _search.width : 0.0;		}		/** *  Scroll to index */		override public function set index(value:int):void {			_pressedCell = value;			if (_slider.x + _rowWidth * value < MAXIMUM_DY/2) {				_endSlider = _rowWidth * value - _offset;				if (_endSlider > _maximumSlide) {					_endSlider = _maximumSlide;				}				_moveTimer.start();							}			else {				scrollPositionX = _rowWidth * value - _offset;			}			sliderMoved();			illuminate(value, false);		}						override protected function initDraw():void {			_rendererAttributes.width = (_rowWidth>0 ? _rowWidth : attributes.width) - 2*_rendererAttributes.paddingH;			_slider.graphics.clear();			resizeRefresh();			_cellTop = _top;		}						override protected function autoLayout():void {			var last:Number = _top + _attributes.paddingH;			for (var i:int = 0;i<_filteredData.length;i++) {				var cell:* = _slider.getChildByName("label_"+i.toString());				if (cell && cell is UIForm) {					UIForm(cell).layout(_rendererAttributes);					cell.x = last;					last += _rendererAttributes.width;					drawCell(last, i);					last += _attributes.paddingH;				}			}		}		/** *  Redraw cell chrome */			override protected function redrawCells():void {			initDraw();			var cellWidth:Number = (_rowWidth>0) ? _rowWidth : _attributes.widthH;			if (!_autoLayout) {				for (var l:int = 0; l < _filteredData.length; l++) {					drawCell(cellWidth*l + _top + _attributes.paddingH, l);				}			}		}		/** *  Set list data */			override protected function set data0(value:Array):void {			clearCells();			initDraw();			if (_simple)				simpleRenderers(value, _cellTop + _attributes.paddingH);			else				customRenderers(value, _cellTop + _attributes.paddingH);			if (_autoLayout)				doLayout();			calculateMaximumSlide();		}		/** *  Calculate maximum slide */			override protected function calculateMaximumSlide():void {			_scrollerWidth = _slider.width;			_maximumSlide = _scrollerWidth - _attributes.widthH; // - _attributes.paddingH;			if (_maximumSlide < 0)				_maximumSlide = 0;		} /** *  Create list with simple default label rows */			override protected function simpleRenderers(value:Array, position:Number = -1):void {			if (position < 0)				position = _attributes.paddingH;			_count = 0;			_textAlign = _attributes.textAlign;			for each (var record:* in value) {				var label:UILabel = labelCell(record, position);				drawCell(position, _count);				position += (_rowWidth>0) ? _rowWidth : _attributes.widthH;				_count++;			}		}		/** *  Create a simple list label row */			override protected function labelCell(record:*, position:Number):UILabel {			var label:UILabel = super.labelCell(record, position);			label.x = position;			label.y = _attributes.paddingV;			return label;		}		/** *  Draw row chrome */			override protected function drawSimpleCell(position:Number, count:int):void {			position = Math.floor(position);			var cellWidth:Number = (_rowWidth>0) ? _rowWidth : _attributes.widthH;			if (_colours.length > 1) {				_slider.graphics.beginFill(_colours[count % (_colours.length - 1) + 1]);				_slider.graphics.drawRect(position - _attributes.paddingH, 0, cellWidth, _attributes.heightV);			}			_slider.graphics.beginFill(0,0);			_slider.graphics.drawRect(position  - _attributes.paddingH, 0, cellWidth, 1);			drawLines(position);			_cellTop = position;		}		/** *  Return DisplayObject of button pressed */		override protected function pressButton():DisplayObject {			_scrollBarLayer.graphics.clear();			_highlight.graphics.clear();			if (!_simple || _slider.mouseX<_top) {				doSearchHit();			}			illuminate();			return _pressButton;		}						override protected function illuminate(pressedCell:int = -1, dispatch:Boolean = true):void {			if (!_pressButton && _clickRow) {				var highlightWidth:Number = (_rowWidth>0) ? _rowWidth : _attributes.widthH;				if (_autoLayout && !_simple && _slider.mouseY > _top) {					_pressedCell = pressedCell>0 ? pressedCell : autoLayoutPressedCell(_slider.mouseX);					if (_row && _pressedCell >= 0 && _pressedCell < _count) {						if (_highlightPressed) {							_highlight.graphics.beginFill(HIGHLIGHT);							_highlight.graphics.drawRect(_row.x - _attributes.paddingH +1, 0, highlightWidth, _row.height + 2*_attributes.paddingV -1 ); //_attributes.x + 						}						activate(dispatch);					}				}				else {					_pressedCell = pressedCell>0 ? pressedCell : Math.floor((_slider.mouseX - _top)/highlightWidth);					if (_pressedCell >= 0 && _pressedCell < _count) {						if (_highlightPressed) {							_highlight.graphics.beginFill(HIGHLIGHT);							_highlight.graphics.drawRect(_top + _pressedCell * highlightWidth +1, 0, highlightWidth, _attributes.heightV); //_attributes.x + 						}						activate(dispatch);					}				}			}		}		/** *  If autoLayout="true", which cell was clicked? */		override protected function autoLayoutPressedCell(x:Number):int {			var n:int = 0;			for (var l:int=0;l<_slider.numChildren - 1;l++) {				var row:* = _slider.getChildAt(l+1);								if (row && row is UIForm) {					_row = UIForm(row);					if (_row.x + _row.width + _attributes.paddingH > x)						return n;					n++;				}			}			return -1;		}		/** *  Create list with custom renderers */		override protected function customRenderers(value:Array, position:Number = -1):void {			if (position < 0)				position = _attributes.paddingH;			_count = 0;			for each (var record:Object in value) {				customCell(record, position);				drawCell(position, _count);				position += (_rowWidth>0) ? _rowWidth : _attributes.widthH;				_count++;			}		}				/** *  Create and position a new list row */		override protected function customCell(record:Object, position:Number):void {			if (!UI.isForm(_renderer.localName()))				_renderer = XML("<horizontal>" + _renderer.toXMLString() + "</horizontal>");			_cell = newRow();			_cell.x = position;			_cell.y = _rendererAttributes.paddingV;			_cell.mouseChildren = false;			_cell.name = "label_"+_count.toString()+_suffix;			fillInValues(_cell, record);		}				/** *  Rearrange the layout to new screen dimensions */			override public function layout(attributes:Attributes):void {			var attributesWidth:Number = attributes.width;			var cellWidth:Number = (_rowWidth>0) ? _rowWidth : _attributes.widthH;			attributes.width = cellWidth;			super.layout(attributes);			attributes.width = attributesWidth;			if (scrollRect) {				scrollRect = new Rectangle(0,0,attributes.widthH,attributes.heightV);			}			calculateMaximumSlide();		}		//____________// There is no multiple inheritance in AS3, so here are the methods of UIScrollHorizontal				/** *  Adjust horizontal scroll range */		override protected function adjustMaximumSlide():void {			_maximumSlide = _slider.width - _attributes.widthH - PADDING * (_border=="false" ? 0 : 1);			if (_maximumSlide < 0)				_maximumSlide = 0;			if (_slider.x < -_maximumSlide)				_slider.x = -_maximumSlide;		}		/** *  Touch move handler */		override protected function mouseMove(event:TimerEvent):void {			if (!_noScroll) {				_delta = -_slider.x;				sliderX = _startSlider.x + (mouseX - _startMouse.x);				_delta += _slider.x;				_distance += Math.abs(_delta);			}			if (_distance > THRESHOLD) {				showScrollBar();			}		}						override protected function startMovement0():Boolean {			var result:Boolean = false;			if (_slider.x > _offset) {				_endSlider = -_offset;				result = result || true;			}			else if (_slider.x < -_maximumSlide ) {				_endSlider = _maximumSlide;				result = result || true;			}					return result;		}				/** *  Animate scrolling movement */		override protected function movement(event:TimerEvent):void {			if (_endSlider<FINISHED) {				_delta *= _decay;				sliderX = _slider.x + _delta;				if (_distance > THRESHOLD)					showScrollBar();				if (Math.abs(_delta) < _deltaThreshold || _slider.x > 0 || _slider.x < -_maximumSlide) {					if (!startMovement0())						stopMovement();				}			}			else {				_delta = (-_endSlider - _slider.x) * BOUNCE;				sliderX = _slider.x + _delta;				showScrollBar();				if (Math.abs(_delta) < _deltaThreshold) {					stopMovement();					sliderX = -_endSlider;				}			}					}		/** *  Show scroll bar */		override public function showScrollBar():void {			var sliderWidth:Number = _scrollerWidth>0 ? _scrollerWidth*_scale : _slider.width;			_scrollBarLayer.graphics.clear();			var barWidth:Number = (_attributes.widthH / sliderWidth) * _attributes.widthH;			var barPositionX:Number = (- _slider.x / sliderWidth) * _attributes.widthH;			if (barWidth < MINIMUM_BAR_WIDTH) {				barPositionX = (_attributes.widthH - 2 * SCROLLBAR_POSITION - MINIMUM_BAR_WIDTH) * barPositionX/(_attributes.widthH - 2 * SCROLLBAR_POSITION - barWidth);				barWidth = MINIMUM_BAR_WIDTH;			}						if (barPositionX < SCROLLBAR_POSITION) {				barWidth += barPositionX;				barPositionX = SCROLLBAR_POSITION;			}			if (barPositionX + barWidth > _attributes.widthH - SCROLLBAR_POSITION) {				barWidth -= barPositionX + barWidth - _attributes.widthH + SCROLLBAR_POSITION;			}			if (barWidth > 0 && barPositionX >= 0) {				_scrollBarLayer.graphics.beginFill(_scrollBarColour);				_scrollBarLayer.graphics.drawRoundRect(barPositionX, _attributes.heightV - SCROLLBAR_WIDTH - SCROLLBAR_POSITION, barWidth, SCROLLBAR_WIDTH, SCROLLBAR_WIDTH);			}			_slider.cacheAsBitmap = true;		}						protected function set sliderX(value:Number):void {			if (Math.abs(value - _slider.x) < MAXIMUM_DY) {				_slider.x = value;			}		}		/** *  Set horizontal scroll position */		public function set scrollPositionX(value:Number):void {			_slider.x = -value;			if (value > _maximumSlide) {				_slider.x = -_maximumSlide;			}		}						public function get scrollPositionX():Number {			return -_slider.x;		}			//____________				override public function destructor():void {			if (_search) {				_search.removeEventListener(TextEvent.TEXT_INPUT, searchHandler);				_search.destructor();			}			super.destructor();		}	}}